= Definition Model

== Overview

The following figure shows the key classes in the `proc.task_planning.definition` package.

[.text-center]
.proc.task_planning.definition model overview
image::{uml_export_dir}/diagrams/PROC-task_planning.definition-structure.svg[id=proc_definition_structure, align="center"]

The remaining classes are shown in various specialised views below.

The top-level structure for defining plans is a `WORK_PLAN`, which includes one or more related `TASK_PLANs` making up a logical goal-oriented plan. Inclusion is achieved via UID references to Task Plans (`WORK_PLAN._plans_` and `WORK_PLAN._top_level_plans_`) rather than physical containment. This relationship allows related Task Plans to be grouped, which occurs for two reasons described earlier: re-use of Task Plans as _sub-plans_ of other Task Plans, and team-based Plans, featuring _hand-offs_ between Task Plans. For a Work Plan, two distinct lists of Task Plans are maintained: `_plans_`, which references all Task Plans, and `_top_level_plans_`, which is a list of those Task Plans that act as the start points for activity for the various actors. Non-top-level plans are those used as sub-plans.

A Work Plan has a number of global attributes, as follows:

* `_context_`: a data context for the Plan as a whole, which enables external variables (such as patient data items) to be tracked and updated;
* `_calendar_`: a global calendar for the Plan, into which entries may be added representing fixed events such as appointments, holidays etc;
* `_timeline_`: the global timeline for the Plan (and hence the subject) into which planned Tasks are fixed, with times specified as offsets from the zero point;
* `_event_wait_states_`: a reference list of all Event wait instances defined in the Plan.

Both `WORK_PLAN` and `TASK_PLAN` are descendants of `CONTENT_ITEM`, which makes them a type of content that may occur in a `COMPOSITION`. Compositions used for this purpose have their `_category_` attribute set to the openEHR coded term `|Work Plan|`. This enables Work Plans to be committed to the openEHR EHR.

As can be seen, the `_definition_` of a `TASK_PLAN` is a `TASK_GROUP`, which has as its `_members_` any number of `PLAN_ITEMs`, which resolve to either `TASK_GROUP` (and some specialisations described below), or `TASK`.

`PLAN_ITEM` has a mandatory `_description_` attribute, which represents a natural language specification of the work of the Task. It also has two optional attributes that control the generic behaviour of Tasks and Groups: `_wait_spec_` and `_repeat_spec_`. The first enables a wait state (described above in the section <<time_and_wait_states,Time and Wait States>>) to be applied to a Task or Group, which is triggered by time-related Events (clock time, reaching a point in a calendar) or other kinds of Events (external notifications etc). This allows the timing of a Task to be specified.

The second attribute, `_repeat_spec_`, enables a Task or Group to be marked as repeating. This is not primarily intended to replace the use of individual Task instances over time, such as repeated medication administrations, but rather to be used to indicate if larger sections (typicaly a Group) of planned Tasks are repeatable. Where repeats are specified, they will be unrolled into literal copies in the materialised expression of the Plan.

=== Task Group Structure

The set of Tasks in a Task Plan is represented within a containment structure created using instances of the `TASK_GROUP` type, which has three key attributes. Execution of a Group is controlled by the `_execution_type_` and `_execution_rules_` attributes, which express sequential or parallel processing, and optionally other execution rules. It also has a `_training_level_` attribute which enables different visibility of Sub-Plans to users with different experience levels. This is described more fully below.

[.tbd]
TBD: other execution rules.

The following illustrates a simple Task Plan structure including nested Task Groups.

[.text-center]
.Task grouping
image::diagrams/task_grouping.svg[id=task_grouping, align="center", width=25%]

The combination of the Task Group / Task hierachical pattern, which implicitly defines the graph structure of the 'normal flow' of a Task Plan, and the generic control attributes enable a significant amount of execution-time Plan processing to be implemented independently of any Task semantics.

=== Class Descriptions

include::{uml_export_dir}/classes/work_plan.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/task_plan.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/task_participation.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/plan_item.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/task_group.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/execution_type.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/execution_rule.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/task.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/task_repeat.adoc[leveloffset=+1]

== Task Actions

The specific definition of the work of Tasks is provided by `TASK._action_`, of type `TASK_ACTION` and its subtypes. Two abstract sub-types distinguish the two basic flavours of Task Action, namely _dispatchable_, meaning 'sent elsewhere for processing', and _performable_, meaning 'defined and performed within the current Plan'. The following UML diagram shows `TASK_ACTION` and its subtypes in detail.

[.text-center]
.proc.task_planning.definition model - Task Actions
image::{uml_export_dir}/diagrams/PROC-task_planning.definition-actions.svg[id=rm_definition_actions, align="center"]

`TASK_ACTION` includes three attributes that apply to all subtypes. The first is `_subject_preconditions_`, which enables subject-related preconditions to be expressed, i.e. conditions referencing variables relating to the subject such as vital signs. These preconditions can be understood as conditions for safe processing, and should either be satisfied before proceeding, or else overridden by a competent performer who understands the implications.

A subject precondition is formally represented as a `BOOLEAN_CONTEXT_EXPRESSION`, whose `_expression_` value is a string in {openehr_expression}[openEHR Expression Language] syntax.

Pre-conditions are evaluated at the point at which the Task to which they are attached becomes available during execution. If any pre-condition evaluates to False, the Task is in theory unable to be performed. A clinical professional may override at execution time, since it may always be the case that particular circumstances obviate the need for a particular pre-condition that normally applies.

[.tbd]
TBD: subject precondition could potentially move to `PERFORMABLE_ACTION`.

The second generally applicable attribute is `_costing_data_`, since cost information may clearly be relevant to any Plan item. Costing is dealt with in detail below.

The third attribute is `_review_dataset_` which provides the ability to specify a data set or form to display when entering a Task, to aid the performer.

In a similar manner, a small number of attributes apply to Dispatchable Actions and Performable Actions. The former class has two attributes to do with managing context change and callback. The `_wait_` flag indicates whether the current Task waits (i.e. blocks) while the dispatched work is performed, or whether it continues on asynchronously. The first constitutes a context switch, the second a context fork. The `_callback_` attribute attaches a special kind of Event-wait that is triggered on receipt of a callback. How callbacks function in detail is described below.

Performable Actions have three attributes. The `_other_participations_` and `_resources_` attributes allow other performers and passive resources to be defined for an Action. Both are subject to an allocation process at execution time, similar to that of the `_principal_performer_`. Finally, the `_capture_dataset_` allows a dataset or form to be specified, for which data must be obtained during the Task execution.

The subtypes of `TASK_ACTION` consist of the following (reading from the right hand side):

* `DEFINED_ACTION`: an inline-defined Task to be performed by the principal performer of the Group (see below for details);
* `SUB_PLAN`: a kind of Task that stands for another Task Plan (identified by the inherited `LINKED_PLAN._target_` attribute) to be performed by the current performer - usually a fine-grained set of steps designed to achieve the result of this Task.
* `SYSTEM_REQUEST`: a kind of Task that consists of a request to a computational system, such as a data retrieval or procedure call, on behalf of the current performer;
* `EXTERNAL_REQUEST`: a Task type that consists of a request to an external organisational entity that is outside the current Work Plan and its execution environment, on behalf of the current performer;
* `HAND_OFF`: a kind of Task that hands off to another Task Plan in the same Work Plan, having a different performer (identified via the `_target_` attribute inherited from `LINKED_PLAN`);

The following sections provide more detail on some of these model features.

=== Performable Actions

==== Sub-plans and Re-use

As described above, multiple Task Plans may be used to define a single logical plan of work. This occurs for two main reasons:

* _re-use_: Task Plans that can be used on their own, e.g. 'set up IV drip', are combined within a larger plan;
* _level of granularity_: a Task Plan can contain Tasks that can be represented as finer-grained Task Plans, which may potentially be used or passed over depending on the level of experience, known here as _training level_ of the performer.

The following instance diagram illustrates.

[.text-center]
.Task Plan linking
image::diagrams/task_linking.svg[id=task_linking, align="center", width=70%]

This shows a Plan for dialysis with a single performer, 'dialysis nurse', and several sub-plans, each referred to by an instance of the `SUB_PLAN` class. Since a Sub-plan is a kind of Task, it has a _description_ and could be performed and signed off as if it were a normal inline `DEFINED_ACTION` by an experienced performer (training level high), or it might be entered into by a performer such as a trainee nurse. The `PLAN_ITME._training_level_` attribute can be used to set the experience level of sub-plans if required; implementing this behaviour at execution time would rely in the Plan execution engine using these settings.

==== Inline Defined Actions

Tasks whose definitions are stated within a Task Plan are modelled using the `DEFINED_ACTION` type. A detailed specification of the work to be done in a Defined Action  may be stated via optional atttribute `_prototype_` of type `ENTRY`, which enables the details of a Task to be specified in terms of a descendant of the `ENTRY` class. This is typically an `ACTION` instance but could be an `OBSERVATION`, `ADMIN_ENTRY` or other descendant. The following view of the UML illustrates.

[.text-center]
.proc.task_planning.definition - Definition Task
image::{uml_export_dir}/diagrams/PROC-task_planning.definition-defined_task.svg[id=proc_task_planning_definition_defined_task, align="center"]

The attribute is called 'prototype' because the target Entry instance is understood as a partially populated, prototype 'planning time' partial copy of an Entry that will be created when the Task is actually performed. For example, a Task Plan for administering medication at 8 hourly intervals over a number of days could consist of a number of `DEFINED_ACTIONs`, each having a protoype of an `ACTION` instance based on the `openEHR-EHR-ACTION.medication.v1` archetype or a templated version thereof. Each such instance would contain the structured description of the medication administration and time, and when the administration was actually performed, an `ACTION` instance would be created from the prototype, modified to reflect any divergence from the planned form of the Task, and committed to the EHR in the normal way.

The following illustrates Task definitions using prototypes.

[.text-center]
.Task definition
image::diagrams/task_definition.svg[id=task_definition, align="center", width=30%]

Assuming that the Task Plan is archetyped in the same way as Entries and other elements of the EHR, this scheme supports various modes of design-time specification. The `_prototype_` attribute in a `TASK_PLAN` archetype will usually be represented by an archetype slot or external reference, which specifies identifiers of permitted archetypes (or templates) of the target type, i.e. `ACTION` or other Entry. This can be used in various ways, as follows:

* {openehr_am_adl2}#_external_references[external reference]: specifies a fixed archetype identifier which will be substituted in the templated form of the Task Plan. This has the effect of creating `ACTION` or other prototype instances in the `TASK_PLAN` structure;
* {openehr_am_adl2}#_archetype_slots[archetype slot]: specified using a slot constraint that is satisfied by one or more archetypes that may be specified by a template, or left open until runtime.

In the latter case, the slot may be filled in the Task Plan template with an `ACTION` or other Entry archetype, allowing the Tasks to be fully specified inline as in the external reference case. Alternatively, it may be left unresolved, which would allow the workflow application to choose the exact Task definition archetype at runtime.

One reason to allow a Task to contain a `_prototype_` reference that remains unresolved until runtime is if the Task represents the act of making an observation, for example, taking a blood pressure. In such cases, no prototype at all may be needed, and the Task `_description_` attribute (inherited from `PLAN_ITEM`) may be sufficient information for the performer. On the other hand, a prototype `OBSERVATION` could be specified in the `TASK_PLAN` template, which defines a particular form of the observation, e.g. a blood pressure which only records mean arterial pressure and cuff size.

To allow further flexibility, The multiplicity of the `_prototype_` attribute is unlimited, to allow for the possibility of one Task being prototyped by more than one Entry instance, e.g. an `ACTION` and an `OBSERVATION`, two `ADMIN_ENTRY` instances and so on.

[.tbd]
ISSUE-task-entry-corr: the alternative seems to be to allow a Task to correspond to e.g. a whole Composition template, where the `COMPOSITION` contains a number of e.g. `ACTIONs` or `OBSERVATIONs`. Problems I see with this: a) who knows what is in the Composition template? It may change over time; b) what if only some of the items in the Composition template can be done? Is the Task half complete? Or should the performer not do any of it?

==== Data-sets and Application Interaction

Within the definition of a Defined Action, one or more data-sets may be specified for review and / or capture purposes (`DEFINED_ACTION._review_dataset_` and `_capture_dataset_`). A 'data-set' in openEHR is a template, normally displayed as a form within an application. Either a template or form identifier (or both) maybe be used to specify a data-set. A review data-set is specified to signal to the Task Plan runtime system to request the display of data at the start of the Task, in order to provide data needed by the user for the Task and potentially following Tasks. A capture data-set is specified when the purpose of the Task is to record data.

[.tbd]
TBD: a single attribute may be sufficient.

=== Dispatchable Actions

The type `DISPATCHABLE_ACTION` is the abstract parent of various Action subtypes that represent work requested to be done by some other agent, i.e. external to the current Task Plan. The general execution scheme for such Actions is as follows:

* _dispatch_ the work request to a target actor or service;
* _block or continue_, according to the `_wait_` flag, which determines switch or fork behaviour; and
* process any _callback notification_, specified via the `_callback_` attribute.

The following sub-sections described the various subtypes of `DISPATCHABLE_ACTION`, while callbacks are described in detail further down.

==== Hand-offs and Coordinated Teamwork

Work Plans may be designed to contain multiple Task Plans, each corresponding to a team worker. In the execution of such a Work Plan, the performer of any Task Plan may at some point need to hand off to another performer, i.e. one of the other Task Plans in the same Work Plan. As described above, the original worker may wait or continue, and in both cases, receipt of a callback notification from the other Task Plan may cause a change in the execution path of the first Plan.

The following illustrates, using the example of an acute stroke management care process.

[.text-center]
.Task coordination
image::diagrams/task_coordination.svg[id=task_coordination, align="center", width=80%]

In this Work Plan, three Task Plans are used to perform (parts of) the clinical work coordinated for managing an acute stroke, as per a Care Pathway. There are two Hand-offs, the first synchronous (`_wait_` = `True`; callback wait resumes at the next Task) and the second an asynchronous fork (`_wait_` = `False`).

==== External Request

The Task sub-type `EXTERNAL_REQUEST` represents a request by the current performer to an external entity completely outside of the current Work Plan computation context to perform some work on behalf of the performer. This is normally an organisation of which routine requests can be made (e.g. pathology laboratory). The request is defined in terms of an organisation identifier, a request identifier (i.e. a name or type of job) and a list of other details, represented by the standard archetypable `ITEM_STRUCTURE`.

==== System Request

In a similar way to External Request, the `SYSTEM_REQUEST` Task sub-type represents a request to a _system_ with a computational interface on behalf of the performer, such as a logging facility or a decision support system. The request is defined in terms of a `SYSTEM_CALL` instance.

=== Class Descriptions

include::{uml_export_dir}/classes/task_action.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/subject_precondition.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/dataset_spec.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/performable_action.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/resource_participation.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/defined_action.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/sub_plan.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/dispatchable_action.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/hand_off.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/external_request.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/system_request.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/linked_plan.adoc[leveloffset=+1]

== Conditional Structures

More advanced applications of Task Plans include three common conditional structures, which may be considered as specific patterns based on the core classes. They are expressed in terms of descendants of `TASK_GROUP` and are illustrated in the following UML model.

[.text-center]
.proc.task_planning package definition model (decision view)
image::{uml_export_dir}/diagrams/PROC-task_planning.definition-decision.svg[id=proc_task_planning_definition_decision, align="center"]

The first pattern is a structure in which a set of Task Groups are treated as separate branches from a common point in the Plan. Each branch is entered conditionally according to the Boolean expression included on the branch. The classes `CONDITION_GROUP` and `CONDITION_BRANCH` provide this structure, which is  equivalent to an if/then/else structure in a programming language. Semantically, the branches are evaluated in order, in the matter of an if/then/else structure, and the final member may be a catch-all branch that matches if nothing else does. Accordingly, the `_execution_type_` is constrained to `sequential`.

The following diagram shows a typical condition structure.

[.text-center]
.Condition structure
image::diagrams/condition_structure.svg[id=condition_structure, align="center", width=40%]

The second structure corresponds to a decision point in a workflow at which some expression is evaluated, and each outgoing branch corresponds to a sub-set of the expression's value range (`_value_constraint_` attribute). The classes `DECISION_GROUP` and `DECISION_BRANCH` provide this structure, which is  equivalent to a switch statement in a programming language. The branch sub-ranges should ideally be individually mutually exclusive, and collectively they should cover the entire value range of the expression. However, as with the Condition Group, the branches are processed in order stated in the definition (`_execution_type_` is constrained to `sequential`), which enables overlapping value constraints on the branches, and also a final catch-all 'else' branch, if needed. The latter would have an open value constraint of the correct type.

The following diagram shows a typical decision structure.

[.text-center]
.Decision structure
image::diagrams/decision_structure.svg[id=decision_structure, align="center", width=40%]

The third structure is a wait state at which multiple branches correspond to the receipt of different events. Taken together, the events constitute a set of logical alternatives at the relevant point in the Plan. This structure is modelled using the classes `EVENT_GROUP` and `EVENT_BRANCH`, and is equivalent to a when / then / else  rules structure in a rule-based programming environment.

[.text-center]
.Event structure
image::diagrams/event_structure.svg[id=event_structure, align="center", width=85%]

=== Class Descriptions

include::{uml_export_dir}/classes/condition_group.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/condition_branch.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/decision_group.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/decision_branch.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/event_group.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/event_branch.adoc[leveloffset=+1]

== Events

=== Event Types

Work plans inevitably interact with events in the external world, as well being driven by time. In this model, points in time are modelled in terms of Events that represent the _reaching_ of certain points in time or an entry in a calendar, as time passes. Consequently, specifying a time for a Task to be performed and waiting for certain Events before it can be performed are both specified in the latter form. The relevant part of the model, shown below, consists of various types of Events, and additionally, various types of _wait states_ that may be used to intercept them.

[.text-center]
.proc.task_planning model - Events
image::{uml_export_dir}/diagrams/PROC-task_planning.definition-event.svg[id=proc_task_planning_definition_event, align="center"]

In the above, the descendants of `PLAN_EVENT` represent various kinds of events, which roughly divide into _deterministic events_, i.e. known, system-endogenous events, and _non-deterministic events_, i.e. events from the outside world whose receipt is not guaranteed.

The event types are as follows:

* `TIMER_EVENT`: represents the expiry of a Timer that was launched at some earlier time;
* `TIMELINE_MOMENT`: represents a time-point within the global Plan timeline that is specified _relative_ to the Plan's start time, and converted to absolute time at activation; this type expresses to what is normally understood as 'clock time' or 'diary' time in the sense of a modern calendar or diary tool, and is how time can be specified directly for Tasks;
* `CALENDAR_EVENT`: represents an event in the global Plan calendar, which is specified in absolute time.
* `TASK_TRANSITION`: an event corresponding to a lifecycle transition of a Task, such as being cancelled or done;
* `CALLBACK_NOTIFICATION`: a callback notification connected to a dispatch call for a Dispatchable Task (Hand-off, External Request, System Request);
* `STATE_TRIGGER`: an event generated by a change in a tracked variable, or an expression based on tracked variables, e.g. a value reaching a threshold;
* `MANUAL_NOTIFICATION`: an event that is manually notified to the Plan execution engine by a user;
* `SYSTEM_NOTIFICATION`: an event that is notified to the Plan execution engine by a system or service;
* `DELAY_EVENT`: a special kind of event is used to represent any other event with an added delay.

Instances of all of these types, on their own only identify the type and source of an event. Events can be waited on in two ways. 

=== Task Wait State

The first way is via the `TASK_WAIT` attachable to any Plan Item, via the `_wait_spec_` attribute, which refers to an instance of `TASK_WAIT`. The `TASK_WAIT` class models a wait state, and defines how to specify the details of when a Task should start with respect to any of the Event types described above. Its `_events_` attribute enables more than multiple Events to be used as a trigger, with an assumed logical OR relation among the Events. This enables the specification of triggers such as 'at 8pm on day 1, or when oxygen saturation drops below 90% (whichever comes first)'. The `_event_relation_` attribute allows the Task to be specified as commencing `before`, `with` or `after` the trigger event (such as a meal). The `_start_window_` attribute allows for a delay from the trigger moment, and  `_timeout_`, if set, will cause a Timer to be started in cases where Event receipt is not certain. These Timers are just special cases of the `EVENT_WAIT` type, described below.

The combined structure of a `TASK_WAIT` and one or more `PLAN_EVENT` descendants provides a way to specify _when_ a Task may be commenced, either in terms of time-related events, or non-deterministic events, as follows:

* _clock time_: the Task is to be executed at a specific clock time represented by an instance of `TIMELINE_MOMENT`; within a Task definition, this must be specified as a relative duration with respect to the origin clock time of the Task Plan, which is only known in absolute terms at execution time;
* _event-linked time_: the Task is to be executed at a time related to a real world event, such as a meal or sleeping; in this case, an instance of `CALENDAR_EVENT` is used; the `TASK_WAIT` attributes indicate the specifics such as '1 hour before', 'with meal' etc;
* _notification-linked time_: the Task is to be executed at a time related to a notification, either from a system (specified with `SYSTEM_NOTIFICATION`) or manually notified (`MANUAL_NOTIFICATION`);
* _task-linked time_: the Task is to be executed at a time related to the timing of another Task lifecycle transition, such as completion of the previous Task; this is represented by an instance of `TASK_TRANSITION` whose `_transition_` indicates the required lifecycle transition;
* _state-linked time_: the Task is to be executed at a time related to the state of the subject, as specified by an instance of `STATE_TRIGGER`. This uses a Boolean-valued `_expression_` attribute to state a condition which when true indicates that a Task time-to-execute has been reached.

The `TIMELINE_MOMENT` type allows a point in time relative to the start of the Plan to be specified, in terms of an offset and a fixed component, both optional. The offset part, if specified, establishes a point relative to the Plan zero point (converted to absolute form at activation), while the fixed part enables fixed points in time such as a particular hour of day or customary time such as 'afternoon' to be specified. A combination of the two such as `+1d, 01:30:00` can thus be used to state a time like '1:30 PM on day one of the plan'.

=== Event Wait State

The second way to intercept events and subsequently perform actions is via an instance of `EVENT_WAIT<T>`, which is a generic class from which concrete types may be constructed based on the type of Event to be listened for. Types such as `EVENT_WAIT<MANUAL_EVENT>` may thus be constructed. The `EVENT_WAIT<T>` class has a `_success_action_` attribute of type `EVENT_ACTION`, which enables any of the following actions to occur on receipt of an event:

* making system calls, if the `_system_call_` attribute is set, e.g. to cause a notification to be sent or write to a system logger;
* displaying a message to the user, specified in the `_message_` attribute.
* optionally indicates where execution should resume in the plan, for example at an earlier Task, via the `_resume_action_` attribute, whose value is aninstance of `RESUME_ACTION`, defining the `_resume_type_` and `_resume_location_` attributes.

The latter attributes are normally only for use with callbacks and are described in detail below.

For non-deterministic Events, the `EVENT_WAIT._timeout_` attribute may be set to point to a `TIMER_WAIT`, which enables timeout actions to be specified.

=== Timers

The class `TIMER_WAIT` is based on the generic type `EVENT_WAIT<TIMER_EVENT>`, and provides a way to specify a Timer (the `TIMER_EVENT` instance) and listen for it (the `TIMER_WAIT`). Timeouts can be used on the `TASK_WAIT` wait state as well as any `EVENT_WAIT` wait state, including `CALLBACK_WAIT`. A `TIMER_WAIT` creates a separate Event wait state that listens for a Timer event launched some duration after activation, and may result in specific actions, specified via the inherited `EVENT_WAIT._success_action_` attribute.

A specialised timer class `REMINDER` can be specified if needed, that consists of a `TIMER_WAIT` designed to generate a user notification.

=== Callbacks

A specialisation of `EVENT_WAIT<CALLBACK_NOTIFICATION>` is `CALLBACK_WAIT`, used to handle notifications of dispatched Tasks that complete, as well as timeouts if no response is received. This class adds one attribute:

* `_fail_action_`: enables a different `EVENT_ACTION` to be specified on receipt of a callback with a 'fail' status;

A Callback Wait can thus have three distinct Event responders: `_success_action_`, `_fail_action_` and `_timeout_`.

=== Class Descriptions

include::{uml_export_dir}/classes/task_wait.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/plan_event.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/delay_event.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/manual_notification.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/system_notification.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/callback_notification.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/state_trigger.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/timer_event.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/calendar_event.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/timeline_moment.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/event_wait.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/timer_wait.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/reminder.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/callback_wait.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/event_action.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/resume_action.adoc[leveloffset=+1]

== Repetition

Repetition may be specified in the model via the attribute `PLAN_ITEM._repeat_spec_`. This is intended to be used to designate sub-sections in a Plan as being repeatable rather than single Tasks, since the main point of a Task Plan is precisely to define individual Tasks in time for execution and sign-off.

== Training Level

One challenge with creating Task Plan definitions is the level of detail to use, with respect to the variable level of skill of different performers. For a senior nurse, a briefer version of the Plan would be preferable with actions such as 'set up IV with catheter' being a single atom, whereas a trainee may need to see a more detailed set of sub-tasks. 

To enable a single Plan to be used in both ways, the concept of 'training level' is included in the model, on the `TASK_GROUP` class. This enables any Group of Tasks to be marked as having a specific training level, where a higher number corresponds to less experience. At execution time, the training level of the allocated performer can be obtained, and then used in comparison to the training level indicated on each Group (including the top-level Group of the whole Plan). If the user training level is higher, then the Group may be shown only as a single step (using its `_description_`, inherited from `PLAN_ITEM`); otherwise it may be shown as the set of sub-steps. This provides a simple way for the same Plan to be presented in different forms matching different performer experience levels.

The default value of `_training_level_` is 0.

== References to Clinical Quality Artefacts

The classes `WORK_PLAN` and `TASK_PLAN` may contain various references to externally defined clinical quality artefacts that they are based on or relate to, as follows:

* In `WORK_PLAN`:
** `_care_plan_`: a reference to an underpinning Care Plan from elsewhere in the EHR, if any exists;
** `_care_pathway_`: references to a care pathway from which this Task Plan was derived, if any;
* In `TASK_PLAN`:
** `_guideline_`: reference to a published guideline from which this particular Task Plan was derived, if any;
** `_best_practice_ref_`: reference to an institutional document that defines the best practice on which this Task Plan is based, if any;
** `_order_set_`: the identifier of an Order Set which this Task Plan uses, if any;
** `_workflow_id_`: an identifier shared among orders (`INSTRUCTIONs` and `ACTIONs`) from the Order Set instance used in this Task Plan, if any.

== Cost Tracking

[.tbd]
TBD: describe cost tracking.

=== Class Descriptions

include::{uml_export_dir}/classes/task_costing.adoc[leveloffset=+1]
